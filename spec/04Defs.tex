\chapter{Обозначения}\label{DEFS}

\section{Список обозначений}

{\tabcolsep 0pt
\begin{longtable}{lrp{14.0cm}}
$\perp$  & \hspace{3mm} &
специальный объект или ситуация: 
пустое слово, игнорируемая переменная, ошибка;
\\[4pt]
%
$\{0,1\}^n$  &&
множество всех слов длины $n$ в алфавите~$\{0,1\}$;
\\[4pt]
%
$\{0,1\}^*$  &&
множество всех слов конечной длины в алфавите~$\{0,1\}$
(включая пустое слово длины $0$);
\\[4pt]
%
$|u|$      &&
длина слова $u\in\{0,1\}^*$;
\\[4pt]
%
$\{0,1\}^{n*}$  &&
множество всех слов из~$\{0,1\}^*$,
длина которых кратна~$n$;
\\[4pt]
%
$\alpha^n$  &&
для $\alpha\in\{0,1\}$ слово из $n$ экземпляров $\alpha$;
\\[4pt]
%
$u[i]$ &&
для $u\in\{0,1\}^n$ и~$0\leq i<n$ символ~$u$ с номером~$i$
(нумерация от~$0$);
\\[4pt]
%
$u[\dots m)$ &&
для~$u\in\{0,1\}^n$ и~$0<m\leq n$ слово $u[0]\ldots u[m-1]$;
\\[4pt]
%
$u[m\dots)$  && 
для~$u\in\{0,1\}^n$ и~$0\leq m<n$, слово~$u[m]u[m+1]\ldots u[n-1]$;
\\[4pt]
%
$u[m_1\dots m_2)$  && 
для~$u\in\{0,1\}^n$ и~$0\leq m_1 <m_2\leq n$ слово
$u[m_1]u[m_1+1]\ldots u[m_2-1]$; 
\\[4pt]
%
$u\parallel v$  &&
для $u\in\{0,1\}^n$ и $v\in\{0,1\}^m$
слово~$w\in\{0,1\}^{n+m}$ такое, что~$w[\dots n)=u$ и~$w[n\dots)=v$
(конкатенация);
\\[4pt]
%
$\Split(u,m)$ &&
для $u\in\{0,1\}^*$ и натурального $m$ представление~$u$
в виде набора $(u_1,u_2,\ldots,u_n)$ фрагментов~$u_i\in\{0,1\}^*$ 
таких, что
$u=u_1\parallel u_2\parallel\ldots\parallel u_n$,
$|u_1|=|u_2|=\ldots=|u_{n-1}|=m$ и $0<|u_n|\leq m$, 
причем набор пуст ($n=0$), если $u=\perp$;
\\[4pt]
%
$\hex{01234\ldots}$ && 
представление $u\in\{0,1\}^{4*}$ шестнадцатеричным словом,
при котором последовательным четырем символам~$u$ соответствует
один шестнадцатеричный символ
(например, $10100010=\hex{A2}$);
\\[4pt]
%
$U\bmod m$             &&
для целого~$U$ и натурального $m$ остаток от деления $U$ на $m$;
\\[4pt]
%
$u\oplus v$             &&
для~$u,v\in\{0,1\}^n$ слово~$w\in\{0,1\}^n$
из символов~$w[i]=(u[i]+v[i])\bmod{2}$
(посимвольное исключающее ИЛИ);
\\[4pt]
%
$\neg u$             &&
для~$u\in\{0,1\}^n$ слово~$u\oplus 1^n$
(посимвольное НЕ);
\\[4pt]
%
$u\wedge v$             &&
для~$u,v\in\{0,1\}^n$ слово~$w\in\{0,1\}^n$
из символов~$w[i]=u[i]*v[i]$
(посимвольное И);
\\[4pt]
%
$u\vee v$             &&
для~$u,v\in\{0,1\}^n$ слово~$w\in\{0,1\}^n$
из символов~$w[i]=(u[i] * v[i]+u[i]+v[i])\bmod{2}$
(посимвольное ИЛИ);
\\[4pt]
%
$\btoi{u}$           &&
а)~для октета~$u\in\{0,1\}^8$
число $2^7 u[0]+2^6 u[1]+\ldots+u[7]$ и\\[2pt]
%
                        &&
б)~для~$u=u_0\parallel u_1\parallel\ldots\parallel u_{n-1}$, 
$u_i\in\{0,1\}^8$,
число~$\btoi{u_0}+2^8\btoi{u_1}+\ldots+2^{8(n-1)}\btoi{u_{n-1}}$;
\\[4pt]
%
$\itob{U}_{8n}$ &&
для неотрицательного целого~$U$ и натурального~$n$
слово $u\in\{0,1\}^{8n}$ такое, что $\btoi{u}=U\bmod 2^{8n}$;
\\[4pt]
%
$\lfloor z\rfloor$        &&
для вещественного $z$ максимальное целое,
не превосходящее $z$;\\[4pt]
%
$\ShLo(u)$                 &&
для~$u\in\{0,1\}^{8n}$ 
слово~$\itob{\left\lfloor\btoi{u}/2\right\rfloor}_{8n}$;
\\[4pt]
%
$\ShHi(u)$                 &&
для~$u\in\{0,1\}^{8n}$ 
слово~$\itob{2\btoi{u}}_{8n}$;
\\[4pt]
%
$\varphi^r(u)$ &&
для слова $u$ и преобразования $\varphi$
результат $r$-кратного действия $\varphi$ на $u$
(например, $\ShLo^r(u)$~--- результат $r$-кратного действия $\ShLo$);
\\[4pt]
%
$\RotHi(u)$             &&
для~$u\in\{0,1\}^{8n}$ 
слово $\ShHi(u)\oplus\ShLo^{8n-1}(u)$;
\\[4pt]
%
$\algname{alg}(u_1,u_2,\ldots)$ &&
вызов алгоритма~\algname{alg} с входными данными~$u_1,u_2,\ldots$;
\\[4pt]
%
$\algname{alg}[p_1,p_2,\ldots]$ &&
алгоритм~\algname{alg} с параметрами $p_1,p_2,\ldots$;
\\[4pt]
%
$a\leftarrow u$         &&
присвоение переменной $a$ значения $u$;
\\[4pt]
%
$\min(u,v)$         &&
минимальное из чисел $u$ и $v$.
\\[4pt]
\end{longtable}
} % tabcolsep
\setcounter{table}{0}

\section{Пояснения к обозначениям}

\subsection{Слова}

Входными и выходными данными алгоритмов настоящего стандарта 
являются двоичные слова~--- последовательности символов 
алфавита~$\{0,1\}$ (битов). Биты нумеруются слева направо от нуля.

В настоящем подразделе в качестве примера рассматривается слово
$$
w=
0000 0001 0010 0011 0100 0101 0110 0111
1000 1001 1010 1011 1100 1101 1110 1111.
$$
В этом слове первые семь битов нулевые, затем~--- $1$, затем~--- два~$0$ и так далее.

Двоичное слово разбивается на тетрады из четверок последовательных битов.
%
Тетрады кодируются шестнадцатеричными символами по правилам,
заданным в таблице~\ref{Table.Hex}.

\begin{table}[H]
\caption{}\label{Table.Hex}
\begin{tabular}{|c|c||c|c||c|c||c|c|}
\hline
тетрада & символ & тетрада & символ & тетрада & символ & тетрада & символ\\
\hline
0000 & $\hex{0}$ & 0001 & $\hex{1}$ & 
0010 & $\hex{2}$ & 0011 & $\hex{3}$\\
0100 & $\hex{4}$ & 0101 & $\hex{5}$ & 
0110 & $\hex{6}$ & 0111 & $\hex{7}$\\ 
1000 & $\hex{8}$ & 1001 & $\hex{9}$ & 
1010 & $\hex{A}$ & 1011 & $\hex{B}$\\ 
1100 & $\hex{C}$ & 1101 & $\hex{D}$ & 
1110 & $\hex{E}$ & 1111 & $\hex{F}$\\ 
\hline
\end{tabular}
\end{table}

Например, слово $w$ кодируется следующим образом:
$$
\hex{0123456789ABCDEF}.
$$

Пары последовательных тетрад образуют октеты.
Последовательные октеты слова $w$ имеют вид:
\begin{align*}
&
0000 0001=\hex{01},\ 
0010 0011=\hex{23},\ 
0100 0101=\hex{45},\  
0110 0111=\hex{67},\\
%
&
1000 1001=\hex{89},\ 
1010 1011=\hex{AB},\ 
1100 1101=\hex{CD},\ 
1110 1111=\hex{EF}.
\end{align*}

\subsection{Слова как числа}

Октету $u=u[0]u[1]\ldots u[7]$ ставится в соответствие байт~--- 
число $\btoi{u}=2^7u[0]+2^6 u[1]+\ldots + u[7]$. 
Например, октетам $w$ соответствуют байты
\begin{align*}
&
1,\ 
35=2^5+2^1+1,\ 
69=2^6+2^2+1,\ 
103=2^6+2^5+2^2+2^1+1,\\
%
&
137=2^7+2^3+1,\ 
171=2^7+2^5+2^3+2^1+1,\
205=2^7+2^6+2^3+2^2+1,\\
&
239=2^7+2^6+2^5+2^3+2^2+2^1+1.
\end{align*}

Число ставится в соответствие не только октету, но и любому другому
двоичному слову, длина которого кратна~$8$. 
%
При этом используется распространенное для многих современных 
процессоров соглашение <<от младших к старшим>> (little-endian):
считается, что первый байт является младшим, последний~--- старшим.
Например, слову $w$ соответствует число
\begin{align*}
\btoi{w}&=
1 + 2^{8}\cdot 35 + 2^{16}\cdot 69 + 2^{24}\cdot 103 + 
2^{32}\cdot 137 + 2^{40}\cdot 171 + 2^{48}\cdot 205 + 2^{56}\cdot 239 =\\
& = 17279655951921914625.
\end{align*}

При отождествлении слов с числами удобно представить себе 
гипотетический регистр, разрядность которого совпадает с длиной слова.
В самый правый октет регистра загружается первый октет слова, 
во второй справа октет регистра~--- второй октет слова и так далее,
пока, наконец, в самый левый октет регистра не загружается последний 
октет слова.
%
Например, для $w$ содержимое регистра имеет 
вид:
$$
\hex{EFCDAB8967452301}
=
%11101111 11001101 10101011 10001001
%01100111 01000101 00100011 00000001
%
11101111 1100 \ldots 0011 00000001.
$$

При таком представлении операции $\ShLo$, $\ShHi$, $\RotHi$ состоят в
сдвигах содержимого регистра: 
$\ShLo$~--- вправо (в сторону младших разрядов),
$\ShHi$~--- влево (в сторону старших разрядов)
и~$\RotHi$~--- циклически влево,
причем при сдвигах $\ShLo$ и~$\ShHi$ в освободившиеся разряды 
регистров записываются нули.
%
Например, предыдущий регистр изменяется при сдвигах следующим образом:
$$      
\begin{array}{rl}
\ShLo: &\hex{77E6D5C4B3A29180}
%=
%0 1110111 1 1100110 1 1010101 1 1000100
%1 0110011 1 0100010 1 0010001 1 0000000
=0 1110111\ldots 1 0000000
,\\
\ShHi: &\hex{DF9B5712CE8A4602}
%= 
%1101111 1 1001101 1 0101011 1 0001001 0
%1100111 0 1000101 0 0100011 0 0000001 0
=1101111 1 \ldots 0000001 0
,\\
\RotHi: &\hex{DF9B5712CE8A4603}
%= 
%1101111 1 1001101 1 0101011 1 0001001 0
%1100111 0 1000101 0 0100011 0 0000001 1
=1101111 1\ldots 0000001 1
.
\end{array}
$$
Выгружая из регистра октеты слева направо, 
получаем следующие результаты:
$$
\begin{array}{rl}
\ShLo(w)=  &\hex{8091A2B3C4D5E677},\\
\ShHi(w)=  &\hex{02468ACE12579BDF},\\
\RotHi(w)= &\hex{03468ACE12579BDF}.
\end{array}
$$

Перестановки октетов при загрузке слова в регистр и при выгрузке из 
регистра в современных процессорах выполняются неявно.

\section{Запись перечислений}\label{DEFS.Seqs}

При записи последовательности~$u_1,u_2,\ldots,u_n$ 
допускается, если не оговорено противное, выполнение неравенства $n<2$.
При $n=0$ идет речь о пустой последовательности, 
а при $n=1$~--- об одноэлементной последовательности $u_1$.

Аналогичные соглашения распространяются на запись конкатенации нескольких 
слов, итератора цикла.
%
Например,
\begin{itemize}
\item
слово $u_1\parallel u_2\parallel\ldots\parallel u_n$ является пустым при $n=0$ 
и состоит из единственного фрагмента~$u_1$ при $n=1$;
\item
тело цикла <<для $i=1,2,\ldots,n$ выполнить~\ldots>>
не выполняется ни разу, если $n=0$, и выполняется один раз, если~$n=1$.
\end{itemize}
