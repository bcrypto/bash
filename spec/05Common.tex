\chapter{Общие положения}\label{COMMON}

\section{Назначение}

Настоящий стандарт определяет семейство криптографических алгоритмов,
построенных по схеме sponge (губка). Схема предложена в~\cite{Sponge}. 
Ядром схемы является sponge-функция, которая определяет сложное биективное 
преобразование двоичных слов большой длины. 

Криптографические алгоритмы делятся на две группы:
\begin{enumerate}
\item[1)]
алгоритмы хэширования (\addendum{см.}~\ref{HASH});
\item[2)]
программируемые алгоритмы (\addendum{см.}~\ref{PRG}).
\end{enumerate}

Алгоритм хэширования по сообщению произвольной длины строит 
хэш-значение~--- слово фиксированной длины.
%
Стороны могут организовать контроль целостности сообщений
путем сравнения их хэш-значений с достоверными контрольными хэш-значениями.
%
Изменение сообщения с высокой вероятностью приводит к изменению
соответствующего хэш-значения, и поэтому хэш-значения могут использоваться
вместо самих сообщений, например в системах ЭЦП.

Алгоритмы хэширования могут дополнительно использоваться при построении 
самих систем ЭЦП, генераторов случайных и псевдослучайных чисел, 
протоколов аутентификации,
криптографических контейнеров, 
% криптографических контейнеров в стиле деревьев Меркля?
доказательств вычислительной работы и др.

Программируемые алгоритмы представляют собой последовательности команд 
криптографического автомата. Разные последовательности дают алгоритмы разного 
назначения: шифрования, имитозащиты, генерации псевдослучайных чисел, 
того же хэширования.
%
В настоящем стандарте объявляются 
правила безопасного программирования (\addendum{см.}~\ref{PRG.Rules}),
явно определяются программируемые алгоритмы хэширования (\addendum{см.}~\ref{PRG.Hash}) 
и аутентифицированного шифрования (\addendum{см.}~\ref{PRG.AE}).

Программируемые алгоритмы хэширования обладают большей гибкостью, чем базовые: 
с их помощью можно вычислять хэш-значения произвольной длины,
а при определенной настройке можно повысить скорость хэширования 
за счет уравнивания гарантий безопасности относительно различных атак.
% без изменения минимального уровня гарантий?
%
Кроме этого, программируемый алгоритм дополнительно принимает на вход анонс,
с помощью которого можно уточнить контекст хэширования.

Алгоритмы аутентифицированного шифрования предназначены для обеспечения 
конфиденциальности, контроля целостности и подлинности данных.
%
Стороны, располагающие общим ключом, могут организовать 
конфиденциальный обмен сообщениями путем их зашифрования 
перед отправкой и расшифрования после получения.
%
Кроме этого, стороны могут организовать контроль целостности при обмене 
сообщениями путем добавления к ним имитовставок при отправке 
и проверки имитовставок при получении.
%
Проверка имитовставок дополнительно позволяет стороне-получателю 
убедиться в том, что сторона-отправитель знает ключ,
т.~е. позволяет проверить подлинность сообщений.

Алгоритмы аутентифицированного шифрования обеспечивают гибкую функциональность.
%
Во-первых, вместе с сообщением контролируется целостность и подлинность 
ассоциированных открытых данных, которые не зашифровываются.
%
Во-вторых, части сообщения и ассоциированных данных могут чередоваться.
%
В-третьих, имитовставки могут выдаваться несколько раз по мере обработки 
частей.
%
В-четвертых, в процессе обработки данных могут обновляться ключи. 

\begin{note}
Примечание~---~Схожие по назначению алгоритмы установлены в СТБ~34.101.31. 
Алгоритмы настоящего стандарта дают дополнительные функциональные возможности.
Например алгоритмы хэширования поддерживают все три уровня стойкости 
алгоритмов ЭЦП, определенных в СТБ 34.101.45, в то время как алгоритм 
хэширования СТБ 34.101.31 поддерживает только первый уровень.
%
Переход от алгоритмов СТБ 34.101.31 к алгоритмам настоящего стандарта позволит 
увеличить скорость обработки данных по крайней мере на паритетном уровне 
стойкости на 64-разрядных аппаратных платформах.
\end{note}

Примеры выполнения алгоритмов стандарта приведены в приложении~\ref{TEST}.
Примеры можно использовать для проверки корректности реализаций 
алгоритмов.

Модуль абстрактно-синтаксической нотации версии~1 (АСН.1), определенной 
в~ГОСТ 34.973, приведен в приложении~\ref{ASN}. Модуль задает идентификаторы 
алгоритмов стандарта, в том числе в их связках с алгоритмами СТБ 34.101.45.
%
Рекомендуется использовать модуль при встраивании алгоритмов в информационные
системы, в которых также используется АСН.1.

\section{Sponge-функция}\label{COMMON.F}

Sponge-функция настоящего стандарта действует на двоичные слова длины~$1536$.  
Действие задается алгоритмом~\algname{bash-f}, определенным в~\ref{F}. 

Sponge-функция~\algname{bash-f} лежит в основе криптографического автомата,
с помощью которого определяются программируемые алгоритмы.

Sponge-функция может использоваться за пределами настоящего стандарта для 
построения других криптографических алгоритмов. 

\section{Уровень стойкости}\label{COMMON.Strength}

Алгоритмы настоящего стандарта отличаются уровнем стойкости~$l$. 

В алгоритмах хэширования это натуральное число, кратное~$16$ и 
не превосходящее~$256$. Уровни $l=128$, $l=192$ и $l=256$
являются стандартными, им следует отдавать предпочтение.

В программируемых алгоритмах yровень стойкости~$l$ 
может принимать только стандартные значения. 

C ростом~$l$ повышается стойкость алгоритмов и одновременно снижается 
их быстродействие. В частности, хэширование на уровне~$l=256$ выполняется 
примерно в $2$~раза медленнее, чем при~$l=128$.

\section{Емкость}\label{COMMON.Capacity}

В программируемых алгоритмах уровень стойкости $l$ сопровождается емкостью 
$d\in\{1,2\}$. Емкость определяет объем внутренней памяти автомата 
программируемого алгоритма. 
%
С увеличением емкости повышаются гарантии безопасности, 
но снижается производительность. 
%
Выбор~$(l,d)=(256,2)$ обеспечивает максимальные гарантии.
Выбор $(l,d)=(128,1)$ дает максимальную производительность. 

В алгоритмах аутентифицированного шифрования речь идет о гарантиях, 
связанных с объемом данных, которые разрешается обработать без смены 
или обновления ключа. 
%
При $d=1$ суммарная длина входных и выходных данных не должна 
превышать~$2^{l/2}$.
%
При $d=2$ ограничений на объем нет. 

В программируемых алгоритмах хэширования в зависимости от емкости 
меняется соотношение между трудоемкостями основных атак 
(см. таблицу~\ref{Table.COMMON.Hash}). При этом минимальная трудоемкость
остается без изменений.

\section{Хэш-значение}\label{COMMON.Hash}

Базовый алгоритм хэширования уровня~$l$ вычисляет хэш-значения~---
двоичные слова длины~$2l$. 
%
Если при выбранном~$l$ требуются не все, а~$n<2l$ символов 
хэш-значения, то должны использоваться первые~$n$ символов.

Программируемый алгоритм хэширования вычисляет хэш-значения 
произвольной заданной длины~$n$.

При выборе~$(l,n)$ следует учитывать данные таблицы~\ref{Table.COMMON.Hash}.
В таблице приводится трудоемкость атак по 
обращению (найти сообщение с заданным хэш-значением),
построению второго прообраза (найти другое сообщение с тем же хэш-значением)
и построению коллизии (найти различные сообщения с одинаковыми хэш-значениями).
%
Величина~$u$ в таблице означает, что для достижения успеха в ходе атаки 
потребуется выполнить порядка~$2^u$ операций.

\begin{table}[hbt]
\caption{Трудоемкость атак на алгоритмы хэширования}\label{Table.COMMON.Hash}
\begin{tabular}{|c|c|c|c|}
\hline
Алгоритм & Обращение & Второй прообраз & Коллизия\\
\hline
\hline
Базовый ($n\leq 2l$) & $n$ & $n$ & $n/2$\\
%\hline
Программируемый ($d=1$) & $\min(n,l)$ & $\min(n,l)$ & $\min(n/2,l)$\\
%\hline
Программируемый ($d=2$) & $\min(n,2l)$ & $\min(n,2l)$ & $\min(n/2,l)$\\
\hline
\end{tabular}
\end{table}

\section{Ключ}\label{COMMON.Key}

В программируемых алгоритмах может использоваться ключ.
%
Это двоичное слово, длина которого кратна 32, не меньше уровня стойкости~$l$ 
и не превосходит~$480$. 

Ключ длины $l$ должен вырабатываться без возможности предсказания, 
распространяться с соблюдением мер конфиденциальности и храниться в секрете.
%
Ключ большей длины может быть избыточным кодом $l$-битового 
ключа, например, дополнительно содержать контрольные биты.

Сразу после \addendum{загрузки} ключа автомат программируемого алгоритма 
переходит в ключевой режим. В этом режиме автомат может выполнять шифрование, 
аутентифицированное шифрование, имитозащиту, генерировать секретные 
псевдослучайные числа.

Пока ключ не введен, автомат остается в бесключевом режиме. Здесь можно только 
хэшировать данные. 

\section{Имитовставка}\label{COMMON.MAC}

С помощью программируемых алгоритмов можно вычислять имитовставки.
Это данные, выгружаемые из автомата программируемого алгоритма,
причем автомат переведен в ключевой режим.

В алгоритмах аутентифицированного шифрования длина имитовставки 
совпадает с уровнем стойкости~$l$. 

В других алгоритмах могут выгружаться имитовставки сколь угодно большой длины
или даже последовательности имитовставок. Имитовставки могут интерпретироваться 
как псевдослучайные числа (биты), а автомат~--- как их генератор.

Псевдослучайные числа являются материалом для создания синхропосылок,
ключей, других криптографических объектов. 
%
Ключи и другие секретные объекты должны строиться по непересекающимся 
фрагментам последовательностей псевдослучайных чисел.
%
Если генерируемый ключ \addendum{используется} для управления другим автоматом, 
то уровень стойкости целевого автомата не должен быть выше уровня стойкости
генерирующего.

\section{Анонс}\label{COMMON.Anounce}

С помощью анонса можно уточнить контекст использования программируемого 
алгоритма~--- сузить назначение, локализовать, задать настройки.
%
Например один анонс может описывать исходящий трафик сети~A, 
второй~--- внутренний трафик сети~B.
%
Алгоритмы разных контекстов, то есть с разными анонсами, 
по-разному обрабатывают одни и те же данные. 

Анонс представляет собой двоичное слово, длина которого кратна~$32$ и не 
превосходит~$480$. Допускаются пустые анонсы.

Анонс указывается в командах инициализации и повторной инициализации
автомата программируемого алгоритма. 

\section{Синхропосылка}\label{COMMON.Nonce}

В алгоритмах аутентифицированного шифрования анонс может содержать 
синхропосылку.

Синхропосылки, которые используются с одним и тем же ключом для шифрования 
различных сообщений, должны быть уникальны: на уровне~$l$ они могут повторяться 
только с вероятностью близкой к~$2^{-l}$. Например, если синхропосылка строится 
как случайное или псевдослучайное число и с одним ключом планируется 
использовать~$q$ синхропосылок длины~$m$, то должно выполняться ограничение
$q^2\cdot 2^l\leq 2^{m+1}$.

Синхропосылки могут быть неявными: в их качестве могут выступать волатильные 
открытые данные, которые обрабатываются до шифрования сообщений.

Более того, синхропосылки могут вообще не использоваться, если 
для автомата алгоритма аутентифицированного шифрования
соблюдается принцип: последовательность команд, выполненная до шифрования, 
уникальна~--- любые две последовательности отличаются либо командами,
либо их входными данными.
%
Принцип заведомо соблюден, если в автомат загружается одноразовый ключ.

Синхропосылка необязательна, если шифрование не 
предполагается, а речь идет только об имитозащите.

При генерации секретных псевдослучайных чисел действуют те же требования к 
синхропосылкам, что и при шифровании.

\section{Интерфейсы}\label{COMMON.IFace}

Определение алгоритма или группы алгоритмов начинается с назначения им 
коротких имен, описания параметров и соглашений о входных и выходных данных.
В совокупности такая вводная информация называется интерфейсом.
%
Например, алгоритму хэширования, определенному в~\ref{HASH}, назначается
имя~$\algname{bash-hash}$, объявляется, что его параметром является уровень
стойкости~$l$. 
%
Алгоритм, полученный из основного определенной настройкой параметров,
считается самостоятельным алгоритмом. Так самостоятельным является алгоритм 
$\algname{bash-hash}[l]$. 
%
В интерфейсе объявляется, что его входными данными является хэшируемое 
слово~$X\in\{0,1\}^*$, выходными~--- хэш-значение~$Y\in\{0,1\}^{2l}$.

С помощью интерфейсов можно лаконично и однозначно 
описывать вызов одних алгоритмов в других.
%        	
Например, вызов алгоритма~$\algname{bash-hash}$ уровня~$l$
записывается как~$Y\leftarrow\algname{bash-hash}[l](X)$.

Алгоритм может вызываться в других алгоритмах настоящего стандарта или 
в алгоритмах других стандартов. И наоборот алгоритм может вызывать другие 
алгоритмы. В последнем случае интерфейс содержит перечень задействованных 
алгоритмов.

\section{Переменные}\label{COMMON.Vars}

В настоящем стандарте переменные алгоритма, которые явно объявляются перед 
определением его шагов, могут содержать критические данные, например, фрагмент 
ключа или промежуточный результат вычислений, который упрощает определение 
этого фрагмента.
%
Речь идет, в том числе, о переменных алгоритма хэширования, 
который может использоваться для обработки критических данных.

При реализации алгоритма объявленные переменные \addendum{следует} очищать после
использования. 
%
Очистке подлежи\addendum{т в} том числе автомат (точнее, его состояние),
задействованный в программируемом алгоритме.
%
\addendum{При организации очистки необходимо учитывать особенности
реализации, например, ситуации, когда} переменная алгоритма представляется
несколькими переменными реализации.

Очистка переменных алгоритма может не выполняться, если алгоритм все-таки 
не обрабатывает и не возвращает критические данные.
%
Переменные могут также не очищаться, если алгоритм выполняется в защищенной 
среде, и доступ к переменным блокируется аппаратными или другими способами.


