\chapter{Общие положения}\label{COMMON}

\section{Назначение}

Настоящий стандарт определяет семейство криптографических алгоритмов,
построенных по схеме sponge (губка). Схема предложена в~\cite{Sponge}. 
Ядром схемы является sponge-функция, которая определяет сложное биективное 
преобразование двоичных слов большой длины. 

Криптографические алгоритмы делятся на две группы:
\begin{enumerate}
\item[1)]
алгоритмы хэширования (см. раздел~\ref{HASH});
\item[2)]
программируемые алгоритмы (см. раздел~\ref{PRG}).
\end{enumerate}

Алгоритм хэширования по сообщению произвольной длины строит 
хэш-значение~--- слово фиксированной длины.
%
Стороны могут организовать контроль целостности сообщений
путем сравнения их хэш-значений с достоверными контрольными хэш-значениями.
%
Изменение сообщения с высокой вероятностью приводит к изменению
соответствующего хэш-значения, и поэтому хэш-значения могут использоваться
вместо самих сообщений, например в системах ЭЦП.

Алгоритмы хэширования могут дополнительно использоваться при построении 
самих систем ЭЦП, генераторов случайных и псевдослучайных чисел, 
протоколов аутентификации,
криптографических аккумуляторов, 
% криптографических аккумуляторов в стиле деревьев Меркля?
доказательств вычислительной работы и др.

Программируемые алгоритмы представляют собой последовательности команд 
криптографического автомата. Разные последовательности дают алгоритмы разного 
назначения: шифрования, имитозащиты, генерации псевдослучайных чисел, 
того же хэширования.
%
В настоящем стандарте объявляются 
правила безопасного программирования (см.~\ref{PRG.Rules}),
явно определяются программируемые алгоритмы хэширования (см.~\ref{PRG.Hash}) 
и аутентифицированного шифрования (см.~\ref{PRG.AE}).

Программируемые алгоритмы хэширования обладают большей гибкостью, 
чем базовые: с их помощью можно вычислять хэш-значения произвольной длины,
а при определенной настройке можно повысить скорость хэширования 
за счет уравнивания гарантий безопасности относительно различных атак.
%
Кроме этого, программируемый алгоритм дополнительно принимает на вход анонс,
с помощью которого можно уточнить контекст хэширования.

Алгоритмы аутентифицированного шифрования предназначены для обеспечения 
конфиденциальности, контроля целостности и подлинности данных.
%
Стороны, располагающие общим ключом, могут организовать 
конфиденциальный обмен сообщениями путем их зашифрования 
перед отправкой и расшифрования после получения.
%
Кроме этого, стороны могут организовать контроль целостности при обмене 
сообщениями путем добавления к ним имитовставок при отправке 
и проверки имитовставок при получении.
%
Проверка имитовставок дополнительно позволяет стороне-получателю 
убедиться в том, что сторона-отправитель знает ключ,
т.~е. позволяет проверить подлинность сообщений.

Алгоритмы аутентифицированного шифрования обеспечивают гибкую функциональность.
%
Во-первых, вместе с сообщением контролируется целостность и подлинность 
ассоциированных открытых данных, которые не зашифровываются.
%
Во-вторых, части сообщения и ассоциированных данных могут чередоваться.
%
В-третьих, имитовставки могут выдаваться несколько раз по мере обработки 
частей.
%
В-четвертых, в процессе обработки данных могут обновляться ключи. 

\begin{note*}
Схожие по назначению алгоритмы установлены в СТБ~34.101.31. 
Алгоритмы настоящего стандарта дают дополнительные функциональные возможности.
Например, алгоритмы хэширования поддерживают все три уровня стойкости 
алгоритмов ЭЦП, определенных в СТБ 34.101.45, в то время как алгоритм 
хэширования СТБ 34.101.31 поддерживает только первый уровень.
%
Переход от алгоритмов СТБ 34.101.31 к алгоритмам настоящего стандарта позволит 
увеличить скорость обработки данных по крайней мере на паритетном уровне 
стойкости на 64-разрядных аппаратных платформах.
\end{note*}

Примеры выполнения алгоритмов стандарта приведены в приложении~\ref{TEST}.
Примеры можно использовать для проверки корректности реализаций 
алгоритмов.

Модуль абстрактно-синтаксической нотации версии~1 (АСН.1), определенной 
в~ГОСТ 34.973, приведен в приложении~\ref{ASN}. Модуль задает идентификаторы 
алгоритмов стандарта, в том числе в их связках с алгоритмами СТБ 34.101.45.
%
Рекомендуется использовать модуль при встраивании алгоритмов в информационные
системы, в которых также используется АСН.1.

\section{Sponge-функция}\label{COMMON.F}

Sponge-функция настоящего стандарта действует на двоичные слова длины~$1536$.  
Действие задается алгоритмом~\algname{bash-f}, определенным в~\ref{F}. 

Sponge-функция~\algname{bash-f} лежит в основе криптографического автомата,
с помощью которого определяются программируемые алгоритмы.

Sponge-функция может использоваться за пределами настоящего стандарта для 
построения других криптографических алгоритмов. 

\section{Уровень стойкости}\label{COMMON.Strength}

Алгоритмы настоящего стандарта отличаются уровнем стойкости~$\ell$. 

В алгоритмах хэширования это натуральное число, кратное~$16$ и 
не превосходящее~$256$. Уровни $\ell=128$, $\ell=192$ и $\ell=256$
являются стандартными, им следует отдавать предпочтение.

В программируемых алгоритмах yровень стойкости~$\ell$ 
может принимать только стандартные значения. 

C ростом~$\ell$ повышается стойкость алгоритмов и одновременно снижается 
их быстродействие. В частности, хэширование на уровне~$\ell=256$ выполняется 
примерно в $2$~раза медленнее, чем при~$\ell=128$.

\section{Емкость}\label{COMMON.Capacity}

В программируемых алгоритмах уровень стойкости $\ell$ сопровождается емкостью 
$d\in\{1,2\}$. 
%
% Емкость определяет объем внутренней памяти автомата программируемого 
% алгоритма. 
%
С увеличением емкости повышаются гарантии безопасности, 
но снижается производительность. 
%
Выбор~$(\ell,d)=(256,2)$ обеспечивает максимальные гарантии.
Выбор $(\ell,d)=(128,1)$ дает максимальную производительность. 

В алгоритмах аутентифицированного шифрования речь идет о гарантиях, 
связанных с объемом данных, которые разрешается обработать без смены 
или обновления ключа. 
%
При $d=1$ суммарная длина входных и выходных данных не должна 
превышать~$2^{\ell/2}$.
%
При $d=2$ ограничений на объем нет. 

В программируемых алгоритмах хэширования в зависимости от емкости 
меняется соотношение между трудоемкостями основных атак 
(см. таблицу~\ref{Table.COMMON.Hash}). При этом минимальная трудоемкость
остается без изменений.

\section{Хэш-значение}\label{COMMON.Hash}

Базовый алгоритм хэширования уровня~$\ell$ вычисляет хэш-значения~---
двоичные слова длины~$2\ell$. 
%
Если при выбранном~$\ell$ требуются не все, а~$n<2\ell$ символов 
хэш-значения, то должны использоваться первые~$n$ символов.

Программируемый алгоритм хэширования вычисляет хэш-значения 
произвольной заданной длины~$n$.

\begin{table}[hbt]
\caption{Трудоемкость атак на алгоритмы хэширования}\label{Table.COMMON.Hash}
\begin{tabular}{|c|c|c|c|}
\hline
Алгоритм & Обращение & Второй прообраз & Коллизия\\
\hline
\hline
Базовый ($n\leq 2\ell$)& $n$ & $n$ & $n/2$\\
%\hline
Программируемый ($d=1$)& $\min(n,\ell)$ & $\min(n,\ell)$ & $\min(n/2,\ell)$\\
%\hline
Программируемый ($d=2$)& $\min(n,2\ell)$ & $\min(n,2\ell)$ & $\min(n/2,\ell)$\\
\hline
\end{tabular}
\end{table}

При выборе~$(\ell,n)$ следует учитывать данные таблицы~\ref{Table.COMMON.Hash}.
В таблице приводится трудоемкость атак по 
обращению (найти сообщение с заданным хэш-значением),
построению второго прообраза (найти другое сообщение с тем же хэш-значением)
и построению коллизии (найти различные сообщения с одинаковыми хэш-значениями).
%
Трудоемкость представлена в таблице в логарифмической форме:
для осуществления атаки трудоемкости~$u$ требуется выполнить порядка~$2^u$ 
операций.

\section{Ключ}\label{COMMON.Key}

В программируемых алгоритмах может использоваться ключ.
%
Это двоичное слово, длина которого кратна 32, не меньше уровня стойкости~$\ell$ 
и не превосходит~$480$. 

Ключ длины $\ell$ должен вырабатываться без возможности предсказания, 
распространяться с соблюдением мер конфиденциальности и храниться в секрете.
%
Ключ большей длины может быть избыточным кодом $\ell$-битового 
ключа, например, дополнительно содержать контрольные биты.

Сразу после загрузки ключа автомат программируемого алгоритма 
переходит в ключевой режим. В этом режиме автомат может выполнять шифрование, 
аутентифицированное шифрование, имитозащиту, генерировать 
псевдослучайные числа для создания секретных объектов.

Пока ключ не введен, автомат остается в бесключевом режиме. Здесь можно только 
хэшировать данные. 

\section{Имитовставка}\label{COMMON.MAC}

С помощью программируемых алгоритмов можно вычислять имитовставки.
Это данные, которые выдает автомат программируемого 
алгоритма, причем автомат переведен в ключевой режим.

В алгоритмах аутентифицированного шифрования длина имитовставки 
совпадает с уровнем стойкости~$\ell$. 

В других алгоритмах могут вычисляться имитовставки сколь угодно 
большой длины или даже последовательности имитовставок. Имитовставки могут 
интерпретироваться как псевдослучайные числа (биты), а автомат~--- как их 
генератор. 

Псевдослучайные числа являются материалом для создания синхропосылок,
ключей, других криптографических объектов. 
%
Ключи и другие секретные объекты должны строиться по непересекающимся 
фрагментам последовательностей псевдослучайных чисел.
%
Если генерируемый ключ используется для управления другим автоматом, 
то уровень стойкости целевого автомата не должен быть выше уровня стойкости 
генерирующего.

\section{Анонс}\label{COMMON.Anounce}

С помощью анонса можно уточнить контекст использования программируемого 
алгоритма~--- сузить назначение, локализовать, задать настройки.
%
Например, один анонс может описывать исходящий трафик сети~A, 
второй~--- внутренний трафик сети~B.
%
Алгоритмы разных контекстов, то есть с разными анонсами, 
по-разному обрабатывают одни и те же данные. 

Анонс представляет собой двоичное слово, длина которого кратна~$32$ и не 
превосходит~$480$. Допускаются пустые анонсы.

Анонс указывается в командах инициализации и повторной инициализации
автомата программируемого алгоритма. 

\section{Синхропосылка}\label{COMMON.Nonce}

В алгоритмах аутентифицированного шифрования анонс может содержать 
синхропосылку.

Синхропосылки, которые используются с одним и тем же ключом для шифрования
различных сообщений, должны быть уникальны: на уровне~$\ell$ они могут
повторяться только с вероятностью, близкой к~$2^{-\ell}$. Например, если
синхропосылка строится как случайное или псевдослучайное число и с одним ключом
планируется использовать~$q$ синхропосылок длины~$m$, то должно выполняться
ограничение $q^2\cdot 2^\ell\leq 2^{m+1}$.

Синхропосылки могут быть неявными: в их качестве могут выступать волатильные 
открытые данные, которые обрабатываются до шифрования сообщений.

Более того, синхропосылки могут вообще не использоваться, если 
для автомата алгоритма аутентифицированного шифрования
соблюдается принцип: последовательность команд, выполненная до шифрования, 
уникальна~--- любые две последовательности отличаются либо командами,
либо их входными данными.
%
Принцип заведомо соблюден, если в автомат загружается одноразовый ключ.

Синхропосылка необязательна, если шифрование не 
предполагается, а речь идет только об имитозащите.

При генерации псевдослучайных чисел, предназначенных для построения 
ключей и других секретных объектов, действуют те же требования к 
синхропосылкам, что и при шифровании.

\section{Интерфейсы}\label{COMMON.IFace}

Определение алгоритма или группы алгоритмов начинается с назначения им 
коротких имен, описания параметров и соглашений о входных и выходных данных.
В совокупности такая вводная информация называется интерфейсом.
%
Например, алгоритму хэширования, определенному в разделе~\ref{HASH}, 
назначается имя~$\algname{bash-hash}$, объявляется, что его параметром является 
уровень стойкости~$\ell$. 
%
Алгоритм, полученный из основного определенной настройкой параметров,
считается самостоятельным алгоритмом. Так, самостоятельным является 
алгоритм $\algname{bash-hash}[\ell]$. 
%
В интерфейсе объявляется, что его входными данными является хэшируемое 
слово~$X\in\{0,1\}^*$, выходными~--- хэш-значение~$Y\in\{0,1\}^{2\ell}$.

С помощью интерфейсов можно лаконично и однозначно 
описывать вызов одних алгоритмов в других.
%        	
Например, вызов алгоритма~$\algname{bash-hash}$ уровня~$\ell$
записывается как~$Y\leftarrow\algname{bash-hash}[\ell](X)$.

Алгоритм может вызываться в других алгоритмах настоящего стандарта или 
в алгоритмах других стандартов. И наоборот, алгоритм может вызывать другие 
алгоритмы. В последнем случае интерфейс содержит перечень задействованных 
алгоритмов.

\section{Переменные}\label{COMMON.Vars}

В настоящем стандарте переменные алгоритма, которые явно объявляются перед 
определением его шагов, могут содержать критические данные, например, фрагмент 
ключа или промежуточный результат вычислений, который упрощает определение 
этого фрагмента.
%
Речь идет в том числе о переменных алгоритма хэширования, 
который может использоваться для обработки критических данных.

При реализации алгоритма объявленные переменные следует очищать после
использования. 
%
Очистке подлежит в том числе автомат (точнее, его состояние),
задействованный в программируемом алгоритме.
%
При организации очистки необходимо учитывать особенности
реализации, например ситуации, когда переменная алгоритма представляется
несколькими переменными реализации.

Очистка переменных алгоритма может не выполняться, если алгоритм все-таки 
не обрабатывает и не возвращает критические данные.
%
Переменные могут также не очищаться, если алгоритм выполняется в защищенной 
среде, и доступ к переменным блокируется аппаратными или другими способами.


